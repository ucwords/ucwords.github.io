<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ziplist - 压缩列表</title>
      <link href="/2021/06/20/ziplist-ya-suo-lie-biao/"/>
      <url>/2021/06/20/ziplist-ya-suo-lie-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信对使用过 Redis 的人来说，数据类型 List 是不会陌生的吧。大多数人需要实现一个队列时候，首选的就是 List 了。但是其实 Redis 的 List 类型有多种实现方式。这篇文章就是介绍其中一种实现 ziplist - 压缩列表。</p><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>一如既往，关于 ziplist 的定义和实现还是放在一对文件中，分别是 ziplist.h 和 ziplist.c。在 ziplist.c 文件的头部有着这么一段注释介绍什么是 ziplist。</p><blockquote><p>ziplist 是一个经过特殊编码的双向链表，旨在提高内存效率。 它存储字符串和整数值，其中整数被编码为实际整数而不是一系列字符。 它允许在 O(1) 时间内在列表的任一侧进行推送和弹出操作。 但是，由于每个操作都需要重新分配 ziplist 使用的内存，因此实际复杂性与 ziplist 使用的内存量有关。</p></blockquote><p>从这段话得到：对于不同的数据类型有着不同的编码方式，理解为会对数据进行压缩，从而达到减少内存使用的目的。但是随着存储的 value 数据级增加，使用 ziplist 所付出的代价也随之增加。</p><h4 id="ziplist-布局"><a href="#ziplist-布局" class="headerlink" title="ziplist 布局"></a>ziplist 布局</h4><p>ziplist 是一个特殊双向链表，不像普通的链表使用前后指针关联在一起，它是存储在连续内存上的。整体的结构布局如下图：<br><img src="https://img-blog.csdnimg.cn/20210530162914153.png#pic_center" alt="在这里插入图片描述"></p><ol><li>zlbytes: 32 位无符号整型，记录 ziplist 整个结构体的占用空间大小。当然了也包括 zlbytes 本身。这个结构有个很大的用处，就是当需要修改 ziplist 时候不需要遍历即可知道其本身的大小。 这个 SDS 中记录字符串的长度有相似之处，这些好的设计往往在平时的开发中可以采纳一下。</li><li>zltail: 32 位无符号整型, 记录整个 ziplist 中最后一个 entry 的偏移量。所以在尾部进行 POP 操作时候不需要先遍历一次。</li><li>zllen: 16 位无符号整型,  记录 entry 的数量， 所以只能表示 2^16。但是 Redis 作了特殊的处理：当实体数超过 2^16  ,该值被固定为 2^16 - 1。 所以这种时候要知道所有实体的数量就必须要遍历整个结构了。</li><li>entry: 真正存数据的结构。</li><li>zlend: 8 位无符号整型, 固定为 255 。为 ziplist 的结束标识。</li></ol><h4 id="entry-结构"><a href="#entry-结构" class="headerlink" title="entry 结构"></a>entry 结构</h4><p>每个 entry 都包含两条信息的元数据为前缀。 第一元数据用来存储前一个 entry 的长度，以便能够从后向前遍历列表。<br> 第二元数据是表示 entry 的编码形式。 用来表示 entry 类型，整数或字符串，在字符串的情况下，它还表示字符串有效的长度。 </p><p>所以一个完整的 ziplist 是这样存储的：</p><p><img src="https://img-blog.csdnimg.cn/20210530170201254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="prelen"><a href="#prelen" class="headerlink" title="prelen"></a>prelen</h5><p>记录前一个 entry 的长度。若前一个 entry 的长度小于 254 , 则使用 1 个字节的 8 位无符号整数来表示。</p><p>若前一个 entry 长度大于等于 254，则使用 5 个字节来表示。第 1 个字节固定为 254 (FE) 作为标识，剩余 4 字节则用来表示前一个 entry 的实际大小。</p><p>所以两种情况下的 entry 结构如下所示：</p><pre><code>1. 前一个 entry 大小不超过 253。&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;2. 前一个 entry 大小超过 253。0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</code></pre><h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>entry 的编码字段取决于条目的内容。</p><p>一、当 entry 是字符串时，编码第 1 个字节的前 2 位将保存用于存储字符串长度的编码类型，后面是字符串的实际长度。 </p><p>如注释中举例：</p><pre><code>1. 长度小于或等于 63 字节（6 位）的字符串值。 “pppppp”表示无符号的 6 位数据长度。|00pppppp| - 1 byte</code></pre><pre><code>2. 长度小于或等于 16383 字节（14 位）的字符串值。14 位的数据采用  big endian 存储。big endian 是一种字节序方式，有Little-Endian、Big-Endian两种。|01pppppp|qqqqqqqq| - 2 bytes</code></pre><pre><code>3. 长度大于或等于 16384 字节的字符串值。采用 big endian 存储且可表示的字符串长度最大2^32-1，所以第一个字节没有用到，所以低6位没有用，所以都是0。|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes </code></pre><p>二、当 entry 是整数时，前 2 位都固定为 1。接下来的 2 位用于指定将在此标头后存储哪种类型的整数。</p><p><em>与 ziplist 标头一样，所有整数都以 Little-Endian 序表示，即使此代码是在 Big-Endian 系统中编译的。</em></p><p>如注释中举例：</p><pre><code>1. 整数编码为 int16_t（2 字节）。|11000000| - 3 bytes</code></pre><pre><code>2. 整数编码为int32_t（4个字节）。|11010000| - 5 bytes</code></pre><pre><code>3. 整数编码为 int64_t（8 字节）。|11100000| - 9 bytes</code></pre><pre><code>4. 整数编码为24位带符号（3个字节）。|11110000| - 4 bytes</code></pre><pre><code>5. 整数编码为 8 位有符号（1 字节）。|11111110| - 2 bytes</code></pre><pre><code>6. 0到12的无符号整数。编码后的值实际上是1到13，因为0000和1111不能用，所以要从编码后的4位值中减去1才能得到正确的值。|1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer</code></pre><pre><code>7. 表示 ziplist 结尾的标识。|11111111|</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>ziplist 为了节省内存，采用了紧凑的连续存储。所以在修改操作下并不能像一般的链表那么容易，需要从新分配新的内存，然后复制到新的空间。</li><li>ziplist 是一个双向链表，可以在时间复杂度为O(1)从下头部、尾部进行pop或push。</li><li>可能会出现连锁更新现象。</li></ol><p>其实使用中并没有直接操作这种数据结构，但是可以设置何种情况下使用它。可以在 Redis 的配置文件中进行设置。</p><p>如有以下可选设置项：</p><ol><li>hash-max-ziplist-entries：hash 类型元素数量超过指定数据后时候。使用 hash 存储， 否则使用压缩表。</li><li>hash-max-ziplist-value： hash 类型元素长度超过指定数据后时候。 使用 hash 存储，否则使用压缩链表。</li><li>zset-max-ziplist-entries：zset 类型 压缩列表 ziplist 最大限制元素数。超过指定值将会使用跳表 skiplist + dict 来存储。</li><li>zset-max-ziplist-value：set 类型 压缩列表 ziplist 最大限制大小。超过指定将会使用跳表 skiplist+dict 来存储。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
