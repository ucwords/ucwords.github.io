<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go - 是面向对象语言吗？</title>
      <link href="/2021/09/21/go-shi-mian-xiang-dui-xiang-yu-yan-ma/"/>
      <url>/2021/09/21/go-shi-mian-xiang-dui-xiang-yu-yan-ma/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章代表博主正式开始学习和使用Go，以前的工作中主要使用一门动态的、解释型和面向对象的脚步语言。是的，你没猜错！它是 PHP。</p><p>Go 是一门编译静态语言，令人疑惑的它究竟是不是面向对象设计的。所以本文就以 OOP 的三大特性进行两门语言的对比，看看 Go 是不是面向对象的。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>受 C 家族语言如PHP、Java等影响，得到一个不成文的结论：没有类(class)设计存在的就不是面向对象语言。</p><p>其中这是不对的，面向对象是一种编程思想，而非一种语言特有的技能。例如javascript 也能通过原型的方式实现面向对象编程，那它该如何归宿呢？</p><p><strong>从严格意义上来说，Go 不是一门面向对象的编程语言。</strong> 但是并不妨碍这门语言大放异彩，如 k8s、docker、微服务、网关等。</p><p>本文的宗旨在于分析按常规OOP的特性下，GO 是否支持或者怎么实现面向对象特性。</p><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>对象是一个由信息及对信息进行处理的描述所组成的整体，是对现实世界的抽象。它是类的实例。</p><p>而在 OOP 开发中，有超过90%的代码是写到一个个类中。类定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</p><p>一个类的定义中常常包含：成员变量、成员方法等。在 PHP 中是这样定义一个类的：</p><blockquote><p>PHP 中方法是依赖于类存在的，是面向对象中定义的，只能通过对象调用（类的静态方法能够通过类名直接调用）；</p><p>函数是单独存在的，是面向过程中定义的。目的是解决一类通用的问题，引入后可以在程序的任何地方直接调用。比如<br>include一个PHP文件，使用里面的函数。</p></blockquote><pre class=" language-php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name">ParentClass</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token keyword">extends</span> <span class="token class-name">ParentClass</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token keyword">public</span> <span class="token variable">$attr</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>        <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span></code></pre><p>上例代码中体现了PHP类的结构体、继承、属性及可见性、构造方法、普通方法等信息。</p><p>前文提到 OOP 是一种编程思想，所以在 Go 中有着类似PHP中类的存在。它就是 <strong>结构(struct)。</strong></p><p>在 Go 中定义一个结构如下：</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Common <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Sex    <span class="token builtin">string</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">*</span>Common    Name <span class="token builtin">string</span>       age  <span class="token builtin">int</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>上例代码在结构 MyStruct 中：*Common 体现了继承的特性，属性首字母的大小写体现了可见性。</p><p>当然也可以使用如下的方式让 结构 能实现构造函数的功能，通常使用结构体工厂方法创建结构体的实例。<br>按惯例，工厂的名字以 new 或 New 开头。</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> MyStruct <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name <span class="token builtin">string</span>       age  <span class="token builtin">int</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">func</span> <span class="token function">NewPeople</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">,</span> age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>MyStruct <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 返回一个指向结构体实例的指针</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>MyStruct<span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token punctuation">,</span> age<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>people <span class="token operator">:=</span> <span class="token function">NewPeople</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span></code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>上一小节中，描述了PHP 和 Go 怎么是实现类似OOP语言中的类定义、继承、封装、可见性性、构造方法等。</p><p>这一小节主要讲解 Go 中方法的实现、方法和函数的区别。</p><p>可以认为在 Go 语言中，结构体就像是类的一种简化形式，而 Go 的方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</p><p>接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。</p><p>但是接收者不能是一个接口类型，因为接口是一个抽象定义，但是方法却是具体实现。所以在接口上定义一个方法是编译失败的。</p><p><strong>所以在 Go 中：一个类型加上它的方法等价于面向对象中的一个类，类型可以是结构体或者任何用户自定义类型。</strong>  方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</p><blockquote><p>但是不同于 OOP 语言的是：类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p></blockquote><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">// 通常形式</span><span class="token keyword">func</span> <span class="token punctuation">(</span>recv receiver_type<span class="token punctuation">)</span> <span class="token function">methodName</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span> <span class="token punctuation">(</span>return_value_list<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 举例 求矩形面积</span><span class="token keyword">type</span> Rectangle <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    a <span class="token builtin">int</span>    b <span class="token builtin">int</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>re <span class="token operator">*</span>Rectangle<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    retun re<span class="token punctuation">.</span>a <span class="token operator">*</span> re<span class="token punctuation">.</span>b<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>myStr <span class="token operator">:=</span> <span class="token function">new</span> <span class="token punctuation">(</span>Rectangle<span class="token punctuation">)</span>myStr<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span>myStr<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">4</span>myStr<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在 Go 中，方法和函数的区别主要是：</p><ol><li>函数将变量作为参数：func func1(recv)，其实体现为一个定义的含义。</li><li>方法在变量上被调用：如上例 myStr.Area()。</li></ol><p>小结：<strong>在 Go 中，类型就是类。Go 拥有类似面向对象语言的类继承的概念。</strong></p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Go 中有 接口 的存在，可以使用它实现很多面向对象的特性。</p><p>接口定义了一组方法（方法集），但是这些方法不包含 实现 逻辑。它们没有被实现（抽象的）。接口里也不能包含变量。</p><p>如下定义：</p><pre class=" language-go"><code class="language-go"><span class="token number">1</span><span class="token punctuation">.</span> 按照约定，只包含一个方法的接口的名字由方法名加 <span class="token punctuation">[</span>e<span class="token punctuation">]</span>r 后缀组成。<span class="token number">2</span><span class="token punctuation">.</span> 接口都很简短，通常它们会包含 <span class="token number">0</span> 个、最多 <span class="token number">3</span> 个方法。<span class="token comment" spellcheck="true">// 矩形有面积、周长的方法</span><span class="token keyword">type</span> Rectangle <span class="token keyword">interface</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">Area</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type    <span class="token function">Girth</span><span class="token punctuation">(</span>param_list<span class="token punctuation">)</span> return_type    <span class="token operator">...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>Go 接口有如下的特点：</p><ol><li>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</li><li>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</li><li>一个类型可以实现多个接口。</li><li>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</li></ol><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token number">1</span><span class="token punctuation">.</span> 一个结构体 Square 和一个接口 Rectangle，接口有一个方法 <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。<span class="token number">2</span><span class="token punctuation">.</span> 在 <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法中创建了一个 Square 的实例。<span class="token number">3</span><span class="token punctuation">.</span> 定义了一个接收者类型是 Square 方法的 <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，用来计算正方形的面积：结构体 Square 实现了接口 Rectangle 。<span class="token number">4</span><span class="token punctuation">.</span> 将一个 Square 类型的变量赋值给一个接口类型的变量。<span class="token comment" spellcheck="true">// 求面积的方法</span><span class="token keyword">type</span> Rectangle <span class="token keyword">interface</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">type</span> Square <span class="token keyword">struct</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    side <span class="token builtin">float32</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>sq <span class="token operator">*</span>Square<span class="token punctuation">)</span> <span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float32</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sq<span class="token punctuation">.</span>side <span class="token operator">*</span> sq<span class="token punctuation">.</span>side<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当然可以继续实现多个结构和方法，从而实现多态的特性。</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    sq1 <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Square<span class="token punctuation">)</span>    sq1<span class="token punctuation">.</span>side <span class="token operator">=</span> <span class="token number">2</span>    <span class="token keyword">var</span> areaIntf Rectangle    areaIntf <span class="token operator">=</span> sq1    <span class="token comment" spellcheck="true">// 简明方式 areaIntf := Shaper(sq1)</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"面积: %f\n"</span><span class="token punctuation">,</span> areaIntf<span class="token punctuation">.</span><span class="token function">Area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>输出： 面积<span class="token punctuation">:</span> <span class="token number">4.000000</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go 语言不是一种 “纯正” 的面向对象编程语言。它没有类和继承的设计体现，但是可以通过一些编程思想从而实现。</p><p> Go 语言里有非常灵活的 接口 概念，所以可以通过它可以实现很多面向对象的特性。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看进程内存占用的正确姿势</title>
      <link href="/2021/08/14/cha-kan-jin-cheng-nei-cun-zhan-yong-de-zheng-que-zi-shi/"/>
      <url>/2021/08/14/cha-kan-jin-cheng-nei-cun-zhan-yong-de-zheng-que-zi-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在使用虚拟机跑PHP脚本，惊讶发现 top 命令看到的进程使用的内存总和竟然大于虚拟机可使用的最大物理内存。其实是分析的方向有些小问题，是因为通常大多数人关注的是 RSS 内存。</p><p>通常在 Linux 操作系统中对内存有着 VSS、RSS、PSS、USS等分类。不管你是用上面提到的 top、还是 ps aux 、或者查看 /proc/process_num(进程号)/status | grep RSS，往往大家下意识观察的都是 RSS。</p><p>往往这也是不太对的… </p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>上面提到在 Linux 中有着VSS、RSS、PSS、USS等指标，通常情况下它们有着占用大小 VSS &gt;= RSS &gt;= PSS &gt;= USS 的规律。先看下图：<br><img src="https://img-blog.csdnimg.cn/4575d81551f8442994e49657dba4b5e6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>VSS - Virtual Set Size</strong>  虚拟耗用内存</p><p>对应上图 - 区域1。</p><p>通常不用于判断进程占用的内存大小，因为它不仅包含共享库占用的全部内存，而且包含分配但未使用内存。</p><p>对于不了解虚拟内存的同学可以先看看博文《<a href="https://blog.csdn.net/m0_51504545/article/details/119082010">Linux - 内存管理</a>》，了解操作系统是怎么做内存管理的。</p><p><strong>RSS - Resident Set Size</strong>  实际使用物理内存</p><p>对应上图 - 区域2 + 3 + 4。</p><p>其实不建议大家使用 RSS 去观察进程内存的占用情况。因为它包含了共享库占用的内存，所以会给大家造成误解。</p><p>共享库是什么？举个例子：比如我们使用 redis 扩展，在编译完成后会有一个 redis.io 的文件，可以理解这就是共享库。当有10个进程都使用了 redis（假如使用1M的内存），这10个进程的 RSS 占用中都包含了 1M 的 redis 共享库内存占用，所以就可能出现前言中提到的现象。所以使用 RSS 查看进程的实际占用是不合适的！</p><p><strong>USS - Unique Set Size</strong> 进程独自占用的物理内存</p><p>对应上图 - 区域2。</p><p>通常建议大家使用 USS 来观察进程实际占用的大小。因为不包含共享库占用的内存，是描述进程真正意义上的内存占用情况。比如你申请了一个数组、new了一个对象，USS 反映了这些内存占用。</p><p>当一个进程被销毁释放了，这部分内存是归还给操作系统的。比如你在验证一个进程是否发生内存泄漏， USS 是你最好的观察指标。</p><p>可以使用 smem 命令查看，下面小节也会举一个实际的例子帮助大家理解。</p><p><strong>PSS - Proportional Set Size</strong>  实际使用的物理内存</p><p>对应上图 - 区域2 + 区域4(按进程数等分区域3)。</p><p>比如有2个进程，那一个进程内存占用 PSS 就等RSS + （共享内存 / 2），也是比较好的进程内存占用的分析指标。当一个进程被销毁释放之后，其占用的共享库那部分比例的PSS 将会再次按比例等分分配给其他使用该共享库的进程。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>上面描诉了内存指标的种类和对其详细的说明。但是毕竟是文字，还是比较空洞的，接下来我用一个实际的例子生动的展示。</p><p>最近在了解 swoole, 下面用 swoole table 共享内存的方式向大家解释为什么使用 RSS 分析内存占用是不恰当的。先看代码：</p><pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span><span class="token comment" spellcheck="true">// 创建一个 swoole_table </span><span class="token variable">$table</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swoole_table</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">column</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> swoole_table<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">TYPE_STRING</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$serv</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">swoole_server</span><span class="token punctuation">(</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> <span class="token number">9500</span><span class="token punctuation">,</span> <span class="token constant">SWOOLE_PROCESS</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// worker_num 开启两个进程</span><span class="token comment" spellcheck="true">// dispatch_mode 开启轮循模式，收到会轮循分配给每一个worker进程。</span><span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>   <span class="token string">'worker_num'</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token string">'dispatch_mode'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">table</span> <span class="token operator">=</span> <span class="token variable">$table</span><span class="token punctuation">;</span><span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'receive'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token variable">$serv</span><span class="token punctuation">,</span> <span class="token variable">$fd</span><span class="token punctuation">,</span> <span class="token variable">$reactorId</span><span class="token punctuation">,</span> <span class="token variable">$data</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>    <span class="token variable">$key</span> <span class="token operator">=</span> <span class="token string">'smem'</span><span class="token punctuation">;</span>    <span class="token variable">$cmd</span> <span class="token operator">=</span> <span class="token function">trim</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token variable">$cmd</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>        <span class="token comment" spellcheck="true">// 读取 用于验证共享内存</span>        <span class="token keyword">case</span> <span class="token string">'get'</span> <span class="token punctuation">:</span>            <span class="token variable">$data</span> <span class="token operator">=</span> <span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">send</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">,</span> <span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 设置 swoole_table 内容</span>        <span class="token keyword">case</span> <span class="token string">'set'</span><span class="token punctuation">:</span>            <span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">table</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">set</span><span class="token punctuation">(</span><span class="token variable">$key</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>                <span class="token string">'data'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token function">str_repeat</span><span class="token punctuation">(</span><span class="token string">"smem"</span><span class="token punctuation">,</span> <span class="token number">512</span><span class="token punctuation">)</span>            <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">send</span><span class="token punctuation">(</span><span class="token variable">$fd</span><span class="token punctuation">,</span> <span class="token string">"OK\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#125;);</span><span class="token variable">$serv</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一步：在终端下执行上面代码，可以看到如下的进程。<br><img src="https://img-blog.csdnimg.cn/34a29c4c19dd4897b4c63f7780896909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到 1331 和 1332 是主进程和管理进程，不在我们此次讨论范围内。主要看 1335 和1336 两个work进程，可以看到这个时候两个进程的 RSS 都是一样的 10140。</p><p>第二步：使用 telnet 请求一个进程，让它往 swoole table 中增加点东西。如下图：<br><img src="https://img-blog.csdnimg.cn/3f9c5e95de7c483491e573ca37010b5e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>忽略我忘记怎么退出，输了几个乱码…</p><p>第三步：现在在看两个work进程的 RSS情况，如下图：<br><img src="https://img-blog.csdnimg.cn/96043301b43346d29f7547e2080748e7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以明显看到进程 1335 明显变大了，但是 1336还是没变。</p><p>第四步：在使用 telnet 让 1336 使用 swoole table 的共享内存，因为开启轮循模式，所以这次请求是 1336 来承接。<br><img src="https://img-blog.csdnimg.cn/fa0b834ef60a4cf69a79a288245a32da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第五步：再来观察两个 work 进程的 RSS情况，见下图：<br><img src="https://img-blog.csdnimg.cn/f76a5cb3b6ea4fb09574bd214c65e05d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>是不是 1336 也涨了，所以得出 RSS 并不能反映内存占用的实际情况。所以我们需要使用 USS 来分析，这时候可以使用 smem 这个工具来查看，请自行安装。</p><p>第六步：使用 smem 分析进程内存占用。<br><img src="https://img-blog.csdnimg.cn/a2cd94e83bca4df9832ad003781ae780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>很直观的看到进程实际使用的内存占用 USS 相比 RSS 是比较少的，也是最能反映内存占用的真实情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文分析了内存占用的指标种类，分别是VSS、RSS、PSS、USS 并对其进行了详细的描述。文中也用一个实际的例子得到一个结论：RSS 并不能直观反映进程占用的真实情况。</p><p>需要反映进程占用的真实情况需要观察 USS 指标，这时候需要借助工具 smem 的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存管理 </tag>
            
            <tag> Rss </tag>
            
            <tag> smem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux - 内存管理</title>
      <link href="/2021/07/25/linux-nei-cun-guan-li/"/>
      <url>/2021/07/25/linux-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="【1】前言"><a href="#【1】前言" class="headerlink" title="【1】前言"></a>【1】前言</h4><p>内存管理是指软件运行时对计算机内存资源的分配和使用的技术。其最主要的目的是如何高效，快速的分配，并且在适当的时候释放和回收内存资源。</p><p>内存管理是操作系统很重要的一部分。作为一个后端开发来说，了解操作系统是如何进行内存管理是必须要的。</p><h4 id="【2】读前须知"><a href="#【2】读前须知" class="headerlink" title="【2】读前须知"></a>【2】读前须知</h4><p>在看正文之前，我们需要先了解一些相关的知识点帮助接下来的理解。</p><h5 id="内存和外存"><a href="#内存和外存" class="headerlink" title="内存和外存"></a>内存和外存</h5><p>内存(RAM )  可以大致理解为在市面上看到的内存条，通常有4G、16G等容量。有着易失性、容量较小、价格偏贵<br>读写很快得特点。这里需要和 CPU 的一二三级缓存分开理解哦。</p><p>外存 就大家所知的磁盘、硬盘等外存设备。有着容量大、价格便宜、随机读写较慢、顺序写速度接近内存、可持久化保持数据等特点。</p><h5 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h5><p>物理内存其实就是内存，但是不是内存的容量大小操作系统都能使用到。比如 32 位的操作系统寻找空间理论上最大只有4G, 除去系统所占可能能使用的只有3.75G。所以不要闹出在 32 位操作系统上使用大于 4G的笑话哦，不过钱多当我没说。</p><p>其对应的空间地址称之为：物理内存地址（Physical Memory Address）。</p><h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h5><p>实际上我们写的程序是没有直接使用到物理内存的，还是使用虚拟内存。操作系统为每个进程分配独立的一套虚拟地址，并提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</p><p>对应的空间地址称之为：虚拟内存地址（Virtual Memory Address）。</p><p>为什么需要做一层中间映射是因为：</p><ol><li>进程空间不隔离，没有权限保护。进程间可以相互读写一份地址，造成安全、无法运行等问题。</li><li>程序运行时候的地址不确定，随机分配。</li><li>内存利用率低，容易造成内存碎片。</li></ol><p>进程持有的虚拟地址是通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。</p><h4 id="【3】正文"><a href="#【3】正文" class="headerlink" title="【3】正文"></a>【3】正文</h4><p>在了解上面的知识背景后，我们知道进程是需要通过虚拟内存来联系到物理内存。接下来我们需要开始了解虚拟内存和物理内存是怎么映射起来的。</p><p>一般会有分段、分页、段页混用三种方式，他们各有优劣。</p><h5 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h5><p>分段（Segmentation）中程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属性的。</p><p>所以说，若运行多个同一个进程它们是可以共用代码分段的，因为可以配置双基址：指令和数据各自配置基址。下面会在讲解。</p><p>首先我们先贴一张图，看着图讲解。</p><p><img src="https://img-blog.csdnimg.cn/332bbdbf9e614b8e8a44f1aa171046d9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如上图所示，在分段模式下虚拟内存地址由段选择因子和段内偏移量构成。</p><p>段选择因子是存储在段寄存器中，其包含了段号(可以理解为段表的ID)。对应的段表中则保存了该虚拟地址对应的物理地址的基地址、偏移量和特权等级等。</p><p>段内偏移量可以取0和用户态最大可用段号之间，一个进程可使用的物理地址范围就是基地址 + 段内偏移量。</p><p>上面提到为什么使用虚拟内存技术的原因，结合上面的图文现在可以解决空间隔离和程序运行时地址不确定两点，但是分段还是比较大的一块块连续的地址，所以没有解决碎片化问题。</p><p>比如现在有 1G  可用的物理内存，这时候进程 A 使用了一半 512MB；进程 B 使用了 128MB; 进程 C 使用了 256MB， 三个进程所使用的内存段是连续的。现在还剩下 128 M 可用。</p><p>这时候进程 B  运行完毕了退出释放内存，这时候 A C之间空了一段 128MB 的内存。我们需要启动一个新的进程 D 它需要200 MB 的内存。现在不管是使用A C 或 C 后的内存都不够了。</p><p>这时候就会使用到一种技术 内存交换(Swap)。系统分配给程序的空间分段映射的是一段连续的物理内存，所以空间不够时可以将程序倒到外置存储中，再寻找足够的内存空间加载。</p><p>把进程 C 内存数据暂时复制到硬盘，给进程 D 分配好内存后在把 C 复制到内存中。这个复制不是一下子全部复制，是分段多次复制。</p><p>所以这种情况就会有这些问题：1，多次交换之后内存碎片会越来越多；2，交换过程涉及到外置存储，速度比内存低很多。3，单一程序不能超过物理内存空间。</p><p>所以为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页方式。</p><h5 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h5><p>分页是为了解决内存分段的内存碎片和内存交换效率低的问题。</p><p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小。这样一个连续并且尺寸固定的内存空间，我们叫页（Page）。在 Linux 下，每一页的大小为 4KB（是不是以前听过4k对齐）。可使用  getconf PAGE_SIZE 看到你的操作系统当前页大小哦。</p><p>我们还是先看图。</p><p><img src="https://img-blog.csdnimg.cn/56b92873e3c24b30b1eaa4b53241905f.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如上图所示虚拟地址与物理地址之间通过页表来映射，页表存储在 CPU 的内存管理单元 （MMU） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p>当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。其实就是触发了一个中断。</p><p>如上图内存空间都是预先划分好的而且页大小默认都不大，释放的内存都是以页为单位释放。所有一定程度上减少了内存碎片。当内存不够时候也是安页为单位进行交换，所以相对于分段交换效率一定程度有提高。</p><p><strong>这时候大家有没有想过，内存是按页划分且页表是每个进程都有一份自己的页表。那多进场下光页表占用的空间也是不小的花费。</strong></p><p>所以这时候会采用多级页表（Multi-Level Page Table）和 TLB（Translation Lookaside Buffer） ，通常称为页表缓存、转址旁路缓存、快表等。这里大家有兴趣自行查阅了。</p><h5 id="段页"><a href="#段页" class="headerlink" title="段页"></a>段页</h5><p>其实有时候也会把分页和分段结合起来，通常称为段页式内存管理。实现方式大致是：</p><ol><li>将程序划分为多个有逻辑意义的段，就是分段机制；</li><li>把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ol><p>所以这时候虚拟内存地址就由段号、段内页号和页内位移三部分组成。下面的图我偷个懒大致画画。</p><p><img src="https://img-blog.csdnimg.cn/51655c8055fb4b80bf22e4347f916716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>所以变成来先得到页表起始地址，得到物理页号，最后将物理页号与页内位移组合，得到物理地址。</p><h4 id="【4】Linux-内存管理"><a href="#【4】Linux-内存管理" class="headerlink" title="【4】Linux 内存管理"></a>【4】Linux 内存管理</h4><p>终于来到本文的最终目的，Linux是怎么实现内存管理的。其实这个和 CPU 的发展历程有关，感兴趣自行查阅。大致总结下来就是开始使用的是段式内存管理，后面由段式内存管理把逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p><p>所以Linux 内存主要采用的是页式内存管理，同时也使用了段机制。每个段都是从 0 地址开始的整个用户态最大可用，所有的段的起始地址都是一样的。</p><p>意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p><p>在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，上面的图中能够体现到。不同位数的系统，地址空间的范围也不同。</p><p>常见的 32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</p><p>尽管每个进程都各自有独立的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p><h4 id="【5】总结"><a href="#【5】总结" class="headerlink" title="【5】总结"></a>【5】总结</h4><p>1）操作系统并没有直接使用物理内存，还是实现了和物理内存映射的虚拟内存。<br>2）虚拟地址与物理地址的映射可分为分段、分页或段页等管理实现。<br>3）使用多级页表来避免页表过大的问题。<br>4）Linux 系统主要采用了分页管理，当然也有分段管理。<br>5）Linxu 系统中虚拟空间分布可分为用户态和内核态两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 内存管理 </tag>
            
            <tag> 分段 </tag>
            
            <tag> 分页 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka -入门</title>
      <link href="/2021/07/01/kafka-ru-men/"/>
      <url>/2021/07/01/kafka-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h3><p>近几年大数据炙手可热，相信大多数开发者多多少少了解或使用过 Kafka。博主也是刚入门的萌新，所以整理学习中的经验总结。授予有缘人。</p><p>Kafka 是什么？它是一款开源的消息引擎系统，是 Apache 基金会的一个顶级开源项目。由 Scala 和 Java 编写, 可惜我都不会。</p><p>对于刚接触 <strong>消息引擎系统（Messaging System）</strong> 这个词来说是有些迷茫的，维基百科中是这样描述：<a href="https://en.wikipedia.org/wiki/Franz_Kafka">是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”</a>。</p><p>简单的理解 Kafka 是在各个系统之间传输消息，从而实现松耦合的异步式数据传递。这时候可能有部分看官会想到一些如 XML、json、Protocol Buffer 等成熟方案，但 Kafka 使用的是纯二进制的字节序列传输信息。所以这也是 Kafka 的优势之一。</p><p>现在了解 Kafka 大致什么，那接下来开始使用起来吧。但在使用之前，需要选择一个合适的 Kafka 方案。是的，Kafka 有好几种。</p><h3 id="Kafka-怎么选"><a href="#Kafka-怎么选" class="headerlink" title="Kafka 怎么选"></a>Kafka 怎么选</h3><p>类似 Linux 有 RedHat、CentOS、Ubuntu等多种发行版本，Kafka 也因为有多个发行商所有有多种版本。比较出名的是有以下几种：</p><table><thead><tr><th>名称</th><th>发行商</th><th>选它理由</th><th>不选它理由</th></tr></thead><tbody><tr><td>Apache Kafka</td><td>Apache</td><td>血脉纯正，社区庞大。</td><td>仅提供最最基础的组件，对小白不友好。</td></tr><tr><td>Confluent Kafka</td><td>Confluent</td><td>免费版类似 Apache 版本，企业版 提供商业服务和更多功能。</td><td>几乎不在大陆发展，缺少社区、资料等，不推荐。</td></tr><tr><td>CDH Kafka</td><td>Cloudera</td><td>完善的平台服务，通过便捷化的界面操作将 Kafka 的安装、运维、管理、监控全部统一在控制台中。对于小白是比较有好的。</td><td>对于深度研究的可玩性不如其他，需要集成平台所以有一定的滞后性。</td></tr></tbody></table><h3 id="Kafka-常用术语"><a href="#Kafka-常用术语" class="headerlink" title="Kafka 常用术语"></a>Kafka 常用术语</h3><p>正所谓：上梁山，说匪话（我瞎编的）。Kafka 中也有一些术语需要使用前了解。</p><p>Kafka 是提供一套完备的消息发布与订阅解决方案的分布式的消息引擎系统。所以消息是一个重要的部分，那消息对应的对象称之为：<strong>主题（Topic）</strong>。这里的主题和 ES   中的索引差不多的意思。</p><p>同样的 Kafka 中也有<strong>生产者（Producer）</strong>和<strong>消费者（Consumer）</strong>，统称为客户端（Clients）。</p><p>采用 S/C 结构的 Kafka 服务端是由名为 Broker 的服务进程构成，即一个 Kafka 集群由多个 <strong>Broker</strong> 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。</p><p>Kafka 是一个高可用的服务，其最重要的就是其备份机制（Replication）。实现方式为把相同的数据拷贝到多台节点上，这些备份称之为 <strong>副本（Replica）</strong>。 这种方式在类似 ES。</p><p>Kafka 的副本分为俩种：<strong>领导者副本（Leader Replica）</strong>和<strong>追随者副本（Follower Replica）</strong>。 其中 领导者副本用于和客户端程序进行交互。追随者副本仅仅被动地追随领导者副本而已，不能与外界进行交互（备胎，其实追随者副本可以理解为 MySQL 的从库一样，但是不同的是 MySQL 从是可以读的）。</p><p>它们工作模式为生产者向领导者副本写消息；消费者从领导者副本读消息。追随者副本仅向领导者副本发送请求，请求领导者把最新生产的消息发给它。</p><p>Kafka 作为一个分布式系统，有着很方便的扩展性。 和 ES、MongoDB 等类似，Kafka 中也有<strong>分区（Partitioning）</strong>的操作。</p><p>Kafka 分区机制是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中（尽管有多个分区）。</p><p>其中分区和副本有这种这样的约束：分区中定义副本，一个分区可包含多个副本。但只能有一个领导者副本，可以多个(N-1 N是副本数)追随者副本。</p><p>上面就是大概的术语了，更多的后面的文章在补充了。接下来看很重要的一点，为什么总是听到有人说 Kafka 很快。</p><h3 id="Kafka-为什么快"><a href="#Kafka-为什么快" class="headerlink" title="Kafka 为什么快"></a>Kafka 为什么快</h3><p>其实 Kafka 快大部分是得益于硬件设备的加持，运用了 零拷贝（Zero-Copy）和 DMA （Direct Memory Access）技术。</p><p>Kafka 作为一个消息系统，所以大多情况是消息的接受和写入，读取和发送。这些操作在大量数据下， I/O消耗是很恐怖的。降低 I/O 的带来的影响 Kafka 是很重视。</p><p><strong>DMA （Direct Memory Access）</strong> 也叫直接内存访问。它是一个相对于 CPU 独立的芯片, 作用是代替 CPU 处理控制内存和 I/O 设备的数据传输。从而减轻 CPU 的负担，让 CPU 做该做的事。</p><p>所以使用 DMA 可以减少 CPU 参与复制的次数，如下图例子, 读取数据往网卡发。<br><img src="https://img-blog.csdnimg.cn/20210701225534123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中 DMA 和 CPU 各拷贝了 2 次，总的拷贝了 4 次。DMA 替 CPU 拷贝了  2 次，所以使用  DMA 是可以降低 CPU 的负载。</p><p>但是一份数据拷贝了 4 次 和 4 次用户态与内核态切换，这是很不划算的，所以 Kafka 也使用了 <a href="https://blog.csdn.net/m0_51504545/article/details/116245486">零拷贝</a> 技术。</p><p>零拷贝可以理解为没有在内存层面去“复制（Copy）”数据。以上面的例子举例。零拷贝下的结构式这样的：</p><p><img src="https://img-blog.csdnimg.cn/20210701231206345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。</p><p>当然还有 G-DMA 等技术，上面的流程还能在优化。更多的可以看博文 《<a href="https://blog.csdn.net/m0_51504545/article/details/116245486">零拷贝-浅谈</a>》。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从 Kafka 是什么、Kafka 版本选择、术语解释、Kafka 复制原理等方面介绍了 Kafka，相信大家都有了一个初步的认识。接下来的博客中会深入介绍 Kafka 使用、原理、工具等。</p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> DMA </tag>
            
            <tag> 零拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>skiplist - 跳表</title>
      <link href="/2021/06/30/skiplist-tiao-biao/"/>
      <url>/2021/06/30/skiplist-tiao-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>跳表(skiplist、跳跃表) 是一个很优秀的数据结构，比如用于 Redis、levelDB等出名的开源项目上。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p><p>它的结构特点在名称能很好的体现出来，就像兔子一样，蹦蹦跳跳。可以结合下面的图有个初步的印象。</p><p><img src="https://img-blog.csdnimg.cn/20210630220021771.png#pic_center" alt="在这里插入图片描述"></p><p>是不是看起来很形象了，接下来看看 Redis  是怎么实现跳表。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p> 本文讲解的版本为 Redis 6.0 ，可以在 server.h 头文件中找到对 skiplist 结构的定义。在 Redis 中，目前使用到跳表的只有 有序集合(zset)。</p><p>定义结构体处有段注释，也指明了跳表在 Redis 中的使用范围了。</p><blockquote><p>ZSETs use a specialized version of Skiplists  </p></blockquote><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 有序集合的结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zset <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 哈希表是一种实现方式。</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 本文主题 跳表 实现方式。</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> zset<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 跳表结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplist <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// zskiplistNode 跳表节点, *header, *tail 头尾指针 </span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 节点的数量</span>    <span class="token keyword">int</span> level<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最大层数</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> zskiplist<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 跳表节点结构体</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> zskiplistNode <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    sds ele<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 成员对象</span>    <span class="token keyword">double</span> score<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分值   作为索引</span>    <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>backward<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 后退指针</span>        <span class="token comment" spellcheck="true">// 节点层结构 数组</span>    <span class="token keyword">struct</span> zskiplistLevel <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">struct</span> zskiplistNode <span class="token operator">*</span>forward<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 前进指针</span>        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 该层向前跨越的节点数量</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> zskiplistNode<span class="token punctuation">;</span></code></pre><p>看完上面的注视相比大家脑海中也构建出一张图了，它应该是长的和下图差不。<br><img src="https://img-blog.csdnimg.cn/2021063022052849.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>比如现在需要查找元素 56。</p><p>若是普通的链表就需要遍历整个链表，直到找到为止。如上图就需要查找 6 次。</p><p>但在跳表中，首先判断节点 56 是大于 34，则去下一层。 节点 56  &lt; 节点 78，然后遍历 节点 34～ 节点 78中间。这时候只有一个节点 56。所以需要查找 3 次就可以找到了。</p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>操作结构的实现在 t_zset.c 文件中（不像 ziplist、quicklist 等是同名的一组文件）。</p><p><strong>创建跳表</strong></p><pre class=" language-c"><code class="language-c">zskiplist <span class="token operator">*</span><span class="token function">zslCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>     zsl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zsl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//  申请内存</span>    zsl<span class="token operator">-></span>level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 默认层级</span>    zsl<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 默认长度</span>        <span class="token comment" spellcheck="true">// 头指针创建， ZSKIPLIST_MAXLEVEL 最大层级为 32，可容纳  2^64   个节点。</span>    zsl<span class="token operator">-></span>header <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 跳表结构的头节点需有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  上面遍历 32 次，生成下面这段结构。</span>    <span class="token comment" spellcheck="true">//   struct zskiplistLevel &amp;#123;</span>    <span class="token comment" spellcheck="true">//       struct zskiplistNode *forward;  // 前进指针</span>    <span class="token comment" spellcheck="true">//       unsigned long span; // 该层向前跨越的节点数量</span>    <span class="token comment" spellcheck="true">//    &amp;#125; level[];</span>     zsl<span class="token operator">-></span>header<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    zsl<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zsl<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>节点插入</strong></p><pre class=" language-c"><code class="language-c">zskiplistNode <span class="token operator">*</span><span class="token function">zslInsert</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> rank<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> level<span class="token punctuation">;</span>    <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isnan</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 遍历找到插入的位置</span>        rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token punctuation">(</span>zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> rank<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>                    <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>                    <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用 zslInsert 的地方需要在 hash 中判断当前插入的元素是否已经存在集合中。</span>    <span class="token comment" spellcheck="true">// 元素不能重复，但是元素的分数是可以重复的。</span>         <span class="token comment" spellcheck="true">// 生成随机值 代表需要插入的层级。 下面会讲解具体实现。</span>    level <span class="token operator">=</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">></span> zsl<span class="token operator">-></span>level<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> zsl<span class="token operator">-></span>length<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>level <span class="token operator">=</span> level<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建节点</span>    x <span class="token operator">=</span> <span class="token function">zslCreateNode</span><span class="token punctuation">(</span>level<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 插入新节点后需要更新前后节点对应的span值。 span 是到下一个节点的跨度 </span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">=</span> <span class="token punctuation">(</span>rank<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新 其他level增加 span 值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> level<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新 后退指针。</span>    x<span class="token operator">-></span>backward <span class="token operator">=</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> zsl<span class="token operator">-></span>header<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token constant">NULL</span> <span class="token punctuation">:</span> update<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">else</span>        zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token punctuation">;</span>    zsl<span class="token operator">-></span>length<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这里需要单独说下这个随机值生成的规则。</span><span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ZSKIPLIST_P = 0.25 ，虽然跳表的时间复杂度和二分查找一样，但是这里并不是 50% 的概率来控制一个节点是否放到下一层，而是 25%。 所以同一层节点下一层间的元素个数并不是一样的哦。</span>    <span class="token comment" spellcheck="true">// 还有的说法是这个值为 0.27更合适。 就是自然常数 e (2.7)。</span>    <span class="token comment" spellcheck="true">// random() 生成的随机数和 0xFFFF(16个1) 做 与运算。</span>    <span class="token comment" spellcheck="true">// 其实就是获取random()（32位）的前16位（或者说低位）。</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        level <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>level<span class="token operator">&lt;</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token punctuation">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>节点删除</strong></p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">zslDelete</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> <span class="token keyword">double</span> score<span class="token punctuation">,</span> sds ele<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span><span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    zskiplistNode <span class="token operator">*</span>update<span class="token punctuation">[</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    x <span class="token operator">=</span> zsl<span class="token operator">-></span>header<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span>                    <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>score <span class="token operator">==</span> score <span class="token operator">&amp;&amp;</span>                     <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        update<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 找到分数和值都一样的元素。</span>    x <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> score <span class="token operator">==</span> x<span class="token operator">-></span>score <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-></span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">zslDeleteNode</span><span class="token punctuation">(</span>zsl<span class="token punctuation">,</span> x<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span>            <span class="token function">zslFreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token operator">*</span>node <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没找到</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 删除的具体逻辑</span><span class="token keyword">void</span> <span class="token function">zslDeleteNode</span><span class="token punctuation">(</span>zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span>x<span class="token punctuation">,</span> zskiplistNode <span class="token operator">*</span><span class="token operator">*</span>update<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新 每一层forward、span。</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> zsl<span class="token operator">-></span>level<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">+</span><span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">=</span> x<span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            update<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-></span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>span <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        x<span class="token operator">-></span>level<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-></span>backward <span class="token operator">=</span> x<span class="token operator">-></span>backward<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        zsl<span class="token operator">-></span>tail <span class="token operator">=</span> x<span class="token operator">-></span>backward<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若删除的层级没有元素 层级减 1。</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>zsl<span class="token operator">-></span>level <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> zsl<span class="token operator">-></span>header<span class="token operator">-></span>level<span class="token punctuation">[</span>zsl<span class="token operator">-></span>level<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        zsl<span class="token operator">-></span>level<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 元素长度减 1。</span>    zsl<span class="token operator">-></span>length<span class="token operator">--</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>源码解读就先到这里，更多的可以直接查看源码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><p>跳表中的搜索、插入、删除操作的时间均为 O(logn)，最坏情况(（level = 1）时间复杂性为 O(n) 。相比之下，在一个有序数组或链表中进行插入/删除操作的时间为 O(n)，最坏情况下为 O(n)。</p><p>它采用随机技术决定链表中哪些节点应增加向前指针以及在该节点中应增加多少个指针。跳表结构的头节点需有足够的指针域，以满足可能构造最大级数的需要，而尾节点不需要指针域。</p><p>不好之处就是多层结构会占用额外的空间，是典型的空间换时间的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> skiplist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zipmap-压缩字典</title>
      <link href="/2021/06/26/zipmap-ya-suo-zi-dian/"/>
      <url>/2021/06/26/zipmap-ya-suo-zi-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>hash 数据类型是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。每个 hash 可以存储 232 - 1 键值对（40多亿）。</p><p>redis 在 hash 类型数量比较小的时候会选择使用 zipmap 来实现存储。先看看 Redis  是怎么定义 zipmap的：</p><blockquote><p>String -&gt; String Map 数据结构优化了大小。 该文件实现了一个数据结构，将字符串映射到其他字符串，实现了一个 O(n) 查找数据结构，该结构设计为非常节省内存。 Redis Hash 类型将这种数据结构用于由少量元素组成的散列，一旦达到给定的元素数量就切换到散列表。 考虑到Redis Hashes多次用于表示由几个字段组成的对象，这在使用内存方面是一个非常大的胜利。</p></blockquote><p>在 zipmap.c 文件的头部注释着这句话，从文中能提炼出几点信息：</p><ol><li>使用字符串类型实现 ziplist 的基本布局，可以粗略描述为 “&lt;key1&gt;&lt;value1&gt;&lt;key…&gt;&lt;value…&gt;“。</li><li>查询时候需要遍历字符串，直至找到。</li><li>使用一块连续的内存。</li></ol><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>其实 zipmap 的实现方式和 ziplist 有着异曲同工之处，可以看这篇博文 《<a href="https://blog.csdn.net/m0_51504545/article/details/117391204">ziplist-压缩链表</a>》。</p><h4 id="zipmap-布局"><a href="#zipmap-布局" class="headerlink" title="zipmap 布局"></a>zipmap 布局</h4><p>如需要储存 “age” =&gt; “19”, “name” =&gt; “ucwords” 这组数据，zipmap 的内存布局是这样的：</p><p><img src="https://img-blog.csdnimg.cn/20210604004045264.png#pic_center" alt="在这里插入图片描述"></p><p>他是连续紧凑放到一个字符串中，所以需要放到一块连续的内存中，这就导致了这种存储方式不适合过多的属性和值。查询时候从头开始遍历，太长的字符串也会导致一定的代价。</p><p> <strong>&lt;zmlen&gt;</strong> </p><p>用来记录 zipmap 的元素个数,  占用一个字节。但是当元素个数大于等于 254 后，想知道元素个数需要遍历整个字符串。</p><p><strong>&lt;len&gt;</strong> </p><p>用来记录下一个字符串(key 或 value)的长度，是可变长度的。</p><ul><li>当下一个字符串(key 或 value)的长度小于等于 253，则使用一个字节来表示。</li><li>当下一个字符串(key 或 value)的长度大于等于 254，则使用五个字节表示。第一个固定为 254，用剩下的四个字节表示具体的长度。字节顺序跟着主机一致，即Little-Endian、Big-Endian和主机保持一样。</li></ul><p><strong>&lt;free&gt;</strong> </p><p>用来记录随后的 value 后面的空闲未使用字节数。是一个无符号的 8 位数字。</p><p>free 的值主要是改变 key 的 value 产生的。如把 “age” =&gt; “19” 变成了 “1” ，就产生了 1 个字节的空闲空间，free 的值就变成了 1。为了保证字符串尽量紧凑，zipmapSet操作中 zipmap会进行调整以使整个字符串尽可能小。</p><p><strong>&lt;end&gt;</strong></p><p>用来记录 zipmap 的结尾符，占用1个字节，其值固定为255 (0xFF)。</p><p>上面举的例字用 zipmap 表达如下：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token string">"\x02\x03age\x02\x0018\x04name\x07\x00ucwords\xff"</span></code></pre><h3 id="zipmap-操作"><a href="#zipmap-操作" class="headerlink" title="zipmap 操作"></a>zipmap 操作</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><strong>空zipmap</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">zipmapNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zm <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    zm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* Length */</span>    zm<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIPMAP_END<span class="token punctuation">;</span>    <span class="token keyword">return</span> zm<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>布局只有 zmlen 和 end 共 2 个字节的结构。</p><p><img src="https://img-blog.csdnimg.cn/20210604010415264.png#pic_center" alt="在这里插入图片描述"></p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>查询只能是按照顺序遍历，所以时间复杂度是 O(N), N 是 元素个数。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 按关键字key查找zipmap，假设totlen不为NULL，函数返回后存放zipmap占用的字节数</span><span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">zipmapLookupRaw</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zm<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> klen<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>totlen<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// zipmap中第1个字节是zmlen字段。zm+1跳过第1个字节</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> zm<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>k <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span>llen<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从前往后查找</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> ZIPMAP_END<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> free<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 确定key字符串的长度</span>        l <span class="token operator">=</span> <span class="token function">zipmapDecodeLength</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 确定保存key字符串长度所须要的字节数，也就是len字段所须要的字节数</span>        llen <span class="token operator">=</span> <span class="token function">zipmapEncodeLength</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 比較当前key与给定key是否匹配</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> l <span class="token operator">==</span> klen <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">memcmp</span><span class="token punctuation">(</span>p<span class="token operator">+</span>llen<span class="token punctuation">,</span>key<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 假设totlen为NULL。表示函数调用者不关心zipmap占用的字节数，此时直接返回p，否则先记录下p指针然后继续遍历</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>totlen <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// p加上llen和l。到了value节点处</span>        p <span class="token operator">+</span><span class="token operator">=</span> llen<span class="token operator">+</span>l<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 确定value字符串的长度</span>        l <span class="token operator">=</span> <span class="token function">zipmapDecodeLength</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 确定保存value字符串长度所须要的字节数，也就是len字段所须要的字节数</span>        p <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">zipmapEncodeLength</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 读出free字段的值（前面我们讲过：free仅仅占用一个字节）</span>        free <span class="token operator">=</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 跳到下一个key节点的</span>        p <span class="token operator">+</span><span class="token operator">=</span> l<span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>free<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* +1 to skip the free byte */</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 到这里遍历完整个zipmap。得到其占用的字节数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>totlen <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">*</span>totlen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-</span>zm<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> k<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="写操作-写或更新"><a href="#写操作-写或更新" class="headerlink" title="写操作(写或更新)"></a>写操作(写或更新)</h4><p>首选判断指定key的键值是否存在，若存在则进行更新操作，否则进行插入操作。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 依据key设置value，假设key不存在则创建对应的键值对。參数update用来辨别更新操作和加入操作。 </span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">zipmapSet</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zm<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> klen<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>val<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vlen<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>update<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> zmlen<span class="token punctuation">,</span> offset<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 计算存储key和value所须要的字节数</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> freelen<span class="token punctuation">,</span> reqlen <span class="token operator">=</span> <span class="token function">zipmapRequiredLength</span><span class="token punctuation">(</span>klen<span class="token punctuation">,</span>vlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> empty<span class="token punctuation">,</span> vempty<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    freelen <span class="token operator">=</span> reqlen<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">)</span> <span class="token operator">*</span>update <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在zipmap中查找key。函数返回后zmlen中保存了zipmap所占用的字节数。</span>    p <span class="token operator">=</span> <span class="token function">zipmapLookupRaw</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span>key<span class="token punctuation">,</span>klen<span class="token punctuation">,</span><span class="token operator">&amp;</span>zmlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 假设key指定的键值对不存在，则对zipmap扩容，为容纳新的键值对准备内存空间</span>        <span class="token comment" spellcheck="true">// zipmapResize运行的是realloc操作</span>        zm <span class="token operator">=</span> <span class="token function">zipmapResize</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span> zmlen<span class="token operator">+</span>reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 此时p指向扩容前zipmap的结尾符，将从这里加入新的键值对</span>        p <span class="token operator">=</span> zm<span class="token operator">+</span>zmlen<span class="token number">-1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 更新zipmap所占用的内存空间大小</span>        zmlen <span class="token operator">=</span> zmlen<span class="token operator">+</span>reqlen<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新zipmap中保存的键值对数量，即zmlen字段</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>zm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> ZIPMAP_BIGLEN<span class="token punctuation">)</span> zm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找到可对应的键值对。运行更新操作。这里须要考虑value节点的空间大小能否够容纳新值 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>update<span class="token punctuation">)</span> <span class="token operator">*</span>update <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 求出旧value节点的空间大小</span>        freelen <span class="token operator">=</span> <span class="token function">zipmapRawEntryLength</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>freelen <span class="token operator">&lt;</span> reqlen<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 旧节点的空间太小，须要扩容操作，zipmapResize函数会又一次分配空间，所以须要记录p指针的偏移量</span>            offset <span class="token operator">=</span> p<span class="token operator">-</span>zm<span class="token punctuation">;</span>            zm <span class="token operator">=</span> <span class="token function">zipmapResize</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span> zmlen<span class="token operator">-</span>freelen<span class="token operator">+</span>reqlen<span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> zm<span class="token operator">+</span>offset<span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 移动旧value节点以后的元素以确保有足够的空间容纳新值（ +1是将尾部结尾符一起移动）</span>            <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token operator">+</span>reqlen<span class="token punctuation">,</span> p<span class="token operator">+</span>freelen<span class="token punctuation">,</span> zmlen<span class="token operator">-</span><span class="token punctuation">(</span>offset<span class="token operator">+</span>freelen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            zmlen <span class="token operator">=</span> zmlen<span class="token operator">-</span>freelen<span class="token operator">+</span>reqlen<span class="token punctuation">;</span>            freelen <span class="token operator">=</span> reqlen<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若现在有一个合适的块，可以在其中写入键/值条目。 如果可用空间过多，请将 zipmap 的尾部移到前面几个字节并缩小 zipmap，因为我们希望 zipmap 非常节省空间。</span>    <span class="token comment" spellcheck="true">// freelen表示经上步骤后流出来的空余空间大小，reqlen表示插入或更新键值对所须要的空间。两者的差就是free字段    的值，假设该值过大zipmap会自己主动调整。以下为实现逻辑。</span>    empty <span class="token operator">=</span> freelen<span class="token operator">-</span>reqlen<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>empty <span class="token operator">>=</span> ZIPMAP_VALUE_MAX_FREE<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 首先，将尾部 &lt;empty> 字节移到前面，然后将 zipmap 的大小调整为较小的 &lt;empty> 字节。</span>        offset <span class="token operator">=</span> p<span class="token operator">-</span>zm<span class="token punctuation">;</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token operator">+</span>reqlen<span class="token punctuation">,</span> p<span class="token operator">+</span>freelen<span class="token punctuation">,</span> zmlen<span class="token operator">-</span><span class="token punctuation">(</span>offset<span class="token operator">+</span>freelen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        zmlen <span class="token operator">-</span><span class="token operator">=</span> empty<span class="token punctuation">;</span>        zm <span class="token operator">=</span> <span class="token function">zipmapResize</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span> zmlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> zm<span class="token operator">+</span>offset<span class="token punctuation">;</span>        vempty <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        vempty <span class="token operator">=</span> empty<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下的操作是讲key和value写入zipmap指定位置</span>    <span class="token comment" spellcheck="true">// 对key的长度编码并写入zipmap中</span>    p <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">zipmapEncodeLength</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>klen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入key字符串</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>key<span class="token punctuation">,</span>klen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 移动指针到value写入位置</span>    p <span class="token operator">+</span><span class="token operator">=</span> klen<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 对value的长度编码并写入zipmap中</span>    p <span class="token operator">+</span><span class="token operator">=</span> <span class="token function">zipmapEncodeLength</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>vlen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入free字段</span>    <span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> vempty<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 写入value</span>    <span class="token function">memcpy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>val<span class="token punctuation">,</span>vlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zm<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    </code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">zipmapDel</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zm<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> klen<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>deleted<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> zmlen<span class="token punctuation">,</span> freelen<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 先查询是否存在于字符串中</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">zipmapLookupRaw</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span>key<span class="token punctuation">,</span>klen<span class="token punctuation">,</span><span class="token operator">&amp;</span>zmlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 进行内存的重新分配</span>        freelen <span class="token operator">=</span> <span class="token function">zipmapRawEntryLength</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p<span class="token operator">+</span>freelen<span class="token punctuation">,</span> zmlen<span class="token operator">-</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-</span>zm<span class="token punctuation">)</span><span class="token operator">+</span>freelen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        zm <span class="token operator">=</span> <span class="token function">zipmapResize</span><span class="token punctuation">(</span>zm<span class="token punctuation">,</span> zmlen<span class="token operator">-</span>freelen<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* 减少 zipmap 长度 */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>zm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> ZIPMAP_BIGLEN<span class="token punctuation">)</span> zm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果找到并删除，则设置为 1。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>deleted<span class="token punctuation">)</span> <span class="token operator">*</span>deleted <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果没有找到键，则指向的整数设置为 0。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>deleted<span class="token punctuation">)</span> <span class="token operator">*</span>deleted <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> zm<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>zipmap 为了节省内存使用了 字符串-字符串映射结构 的一种方式，其紧凑的排列方式在内存占用量上还是有不小的优化。但有利有弊，因为使用了一块连续的内存空间，zipmap 的每一次插入、删除、更新操作都有可能造成空间的又一次分配。</p><p>可以用以下参数对来控制 hash 使用 zipmap 。</p><p>hash-max-zipmap-entries 使用 zipmap 的最大元素个数。<br>hash-max-zipmap-value 使用 zipmap 的最大字符串字节长度。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> zipmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>quicklist-快速列表</title>
      <link href="/2021/06/26/quicklist-kuai-su-lie-biao/"/>
      <url>/2021/06/26/quicklist-kuai-su-lie-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇博文用来解读 Redis 数据类型  List 的一种实现。数据结构 quicklist。虽然 List 类型有多种实现，但 quicklist 是最常用的。</p><p>quicklist 是一个双向链表，但同时也是一个复合的结构体。结构中包括了另一种结构 ziplist。如果不熟悉这种结构体，请先阅读这篇博文：《<a href="https://blog.csdn.net/m0_51504545/article/details/117391204">ziplist - 压缩列表</a>》。</p><p>文中介绍了 ziplist 是一种十分节省内存的结构，紧凑的内存布局、变长的编码方式在内存使用量上有着不小的优势。但是修改操作下并不能像一般的链表那么容易，需要从新分配新的内存，然后复制到新的空间。</p><p>所以结合了 ziplist 节省内存和双向链表优点的 quicklist 产生了。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>在 quicklist.c 中可以找到名为 quicklist 的结构体：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklist <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>            <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>             <span class="token keyword">int</span> fill <span class="token punctuation">:</span> QL_FILL_BITS<span class="token punctuation">;</span>                 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> compress <span class="token punctuation">:</span> QL_COMP_BITS<span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bookmark_count<span class="token punctuation">:</span> QL_BM_BITS<span class="token punctuation">;</span>    quicklistBookmark bookmarks<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> quicklist<span class="token punctuation">;</span></code></pre><p>这个结构体定义了 quicklist 的布局，在 64 位的操作系统中它使用了 40 字节。看起来不是很复杂。结构中的各项代表含义如下：</p><ul><li><strong>quicklistNode</strong>：32字节的结构体，用于描述 ziplist 的节点。这里很明显的体现了 quicklist 是一个复合的数据类型，在本版本中是且包含了 ziplist 的，未来可能会出现其他的结构体最为可选项。</li><li><strong>count</strong>：记录所有节点中 ziplist 的所有 entry 的数量。比如有 2 个节点，每个节点中 ziplist 有 3 个 entry 。那这个值就是 6。</li><li><strong>len</strong>： 记录所有节点的数量。</li><li><strong>fill</strong>：记录控制节点中 ziplist 的最大 entry 个数，由参数 list-max-ziplist-size 控制。</li><li><strong>compress</strong> ：记录控制 quicklist 左右两边 quicklistNode 不被压缩的个数，由参数 list-compress-depth 控制。取 0 时候代表不压缩，大于0 代表前后分别被压缩的个数。</li><li><strong>bookmark_count</strong> ：记录数组 bookmarks[] 的长度。Redis 高版本 6.0 才新加的。</li><li><strong>bookmarks</strong> ：quicklist重新分配内存空间时使用，否则只是声明不张占用内存空间。同样也是 6.0 后新增。 </li></ul><h4 id="quicklistNode"><a href="#quicklistNode" class="headerlink" title="quicklistNode"></a>quicklistNode</h4><p>接下来继续解读用来描述 ziplist 的 quicklistNode 结构，同样在在 quicklist.c 中可以找到名为 quicklistNode 的结构体：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklistNode <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>prev<span class="token punctuation">;</span>    <span class="token keyword">struct</span> quicklistNode <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>                 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> quicklistNode<span class="token punctuation">;</span></code></pre><p>Redis 会将 quicklistNode 控制在 32 个字节大小，其中每项的定义如下：</p><ul><li><strong>quicklistNode</strong> <em>prev、</em>next ：记录前后节点的指针，quicklist 是一个双向链表。</li><li> <strong>*zl</strong>：指针类型。若当前节点没有被压缩，则指向 ziplist 结构；否则指向 quicklistLZF 结构，下面还会解读。</li><li><strong>sz</strong>：记录 ziplist 总字节数。包括所有的结构，若不记得了，先去看看文章：《<a href="https://blog.csdn.net/m0_51504545/article/details/117391204">ziplist - 压缩列表</a>》。</li><li><strong>count</strong>：记录 ziplist 的 entry总个数。</li><li><strong>encoding</strong>：记录当前节点是否被压缩，若被压缩则也同时指定压缩算法。当前版本只有 RAW==1 or LZF==2 取值。1代表没压缩；2代表被压缩且使用了 LZF 压缩算法。这个算法可以在 lzf.c 文件中了解。</li><li><strong>container</strong>：记录节点数据是使用那种结构存储。目前版本默认选择 ziplist ，取值范围 NONE==1 or ZIPLIST==2 ，是一个预留的字段，可能后续还会出现其他的结构。</li><li><strong>recompress</strong>：记录标记该节点是否需要被压缩。当取值为 1 时候需要被压缩。</li><li><strong>attempted_compress</strong>：自动化测试程序才有用。</li><li><strong>extra</strong>：预留字段，可能后面的版本会使用。</li></ul><h4 id="quicklistLZF"><a href="#quicklistLZF" class="headerlink" title="quicklistLZF"></a>quicklistLZF</h4><p>上面 quicklistNode 若是被压缩则会使用 quicklistLZF 机构，它的布局是比较简单的：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> quicklistLZF <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* LZF size in bytes*/</span>    <span class="token keyword">char</span> compressed<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> quicklistLZF<span class="token punctuation">;</span></code></pre><p>代码中注释：quicklistLZF is a 4+N byte struct holding ‘sz’ followed by ‘compressed’。</p><ul><li><strong>sz</strong>：记录压缩后 ziplist 的字节长度。</li><li><strong>compressed</strong>：记录存放压缩后的 ziplist 字节数组。</li></ul><h4 id="布局结构"><a href="#布局结构" class="headerlink" title="布局结构"></a>布局结构</h4><p>首先我们思考一个问题，一个数据结构的好坏大致会受空间、时间复杂度的影响。quicklis 的出现也正是考虑到这点，想在俩者之间找到一个最佳的平衡点。所以它使用了双向链表加 ziplist 的复合组合，第一 双向链表能在头尾在 O(1)下找到一个元素，若是在中部查找则平均复杂度也只是O(N)，N 是 entry 的个数。第二 ziplist 使用了紧凑布局和可变编码方式大大降低了内存的使用。这就是 quicklis 作为 List 首选的实现方案。</p><p>但是若是 quicklistNode 中 ziplist 的 entry 的个数设置的不恰当，那 quicklist 的性能也会大幅降低。比如下面的情况：</p><ul><li>list-max-ziplist-size 设置过小，甚至为 1 。这时候 quicklist 性能上就退化和普通双向链表一样。在内存使用上就不能体验到 ziplist 的优势。</li><li> list-max-ziplist-size 设置过大，甚至所有的元素都存储在一个节点中，ziplist 的缺点就会被放大。ziplist 需要一段连续的内存，且修改时候会发生内存的复制。</li></ul><p>所以在实际使用中，要根据数据特点设置一个比较合理的值。</p><p> list-max-ziplist-size 取值范围可以是正数也可以是负数，不能为 0 。当取正数时候代表每个 ziplist 可以存储的最大 entry 数。负数时候去值范围只能是 -5～-1 ，各自代表 ziplist 最大字节大小。</p><p>布局图：</p><p><img src="https://img-blog.csdnimg.cn/2021060600222610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>对于 List 来说：最重要、常用的操作无非就是 push、pop、len等。在 quicklist 中定义了这些操作的函数接口。</p><p>当往 List 中 push 元素时候，若 list 不存在 。会先创建一个空的 quicklist , 初始化各项。代码比较清晰，看一下即可明白。</p><pre class=" language-c"><code class="language-c">quicklist <span class="token operator">*</span><span class="token function">quicklistCreate</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// quicklist 结构体</span>    <span class="token keyword">struct</span> quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内存分配，该函数具体逻辑可以看 zmalloc.c 文件</span>    quicklist <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>quicklist<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 下面都是初始化赋值</span>    quicklist<span class="token operator">-></span>head <span class="token operator">=</span> quicklist<span class="token operator">-></span>tail <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>compress <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>fill <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>bookmark_count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> quicklist<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>若 list 存在，则调用 quicklistPush 函数进行 push 操作。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">quicklistPush</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">const</span> size_t sz<span class="token punctuation">,</span> <span class="token keyword">int</span> where<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断 push 方向 调用实际的 push 函数。</span>    <span class="token comment" spellcheck="true">// 头部</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_HEAD<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>where <span class="token operator">==</span> QUICKLIST_TAIL<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 尾部</span>        <span class="token function">quicklistPushTail</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>实际上 quicklistPushHead 和 quicklistPushTail 函数的逻辑是一样的，这里就只用 quicklistPushHead 进行解析。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">quicklistPushHead</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    quicklistNode <span class="token operator">*</span>orig_head <span class="token operator">=</span> quicklist<span class="token operator">-></span>head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断节点上的 ziplist 是否操作配置设置的大小， 若没有超过 _quicklistNodeAllowInsert 函数返回 1。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">_quicklistNodeAllowInsert</span><span class="token punctuation">(</span>quicklist<span class="token operator">-></span>head<span class="token punctuation">,</span> quicklist<span class="token operator">-></span>fill<span class="token punctuation">,</span> sz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调用 ziplistPush 往 ziplist 中添加一个 entry</span>        quicklist<span class="token operator">-></span>head<span class="token operator">-></span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span>quicklist<span class="token operator">-></span>head<span class="token operator">-></span>zl<span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 更新记录 ziplist 总字节数 </span>        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>quicklist<span class="token operator">-></span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 创建一个新的 节点</span>        quicklistNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">quicklistCreateNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用 ziplistPush 往 ziplist 中添加一个 entry</span>        node<span class="token operator">-></span>zl <span class="token operator">=</span> <span class="token function">ziplistPush</span><span class="token punctuation">(</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> sz<span class="token punctuation">,</span> ZIPLIST_HEAD<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 更新记录 ziplist 总字节数 </span>        <span class="token function">quicklistNodeUpdateSz</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 实际上是调用 __quicklistInsertNode 根据 after 的值，判断 new_node 插入位置。相对于 old_node。</span>        <span class="token function">_quicklistInsertNodeBefore</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> quicklist<span class="token operator">-></span>head<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ziplist 的 entry 个数加一</span>    quicklist<span class="token operator">-></span>count<span class="token operator">++</span><span class="token punctuation">;</span>    quicklist<span class="token operator">-></span>head<span class="token operator">-></span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>orig_head <span class="token operator">!=</span> quicklist<span class="token operator">-></span>head<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>解读完 push 操作后，接着解读 pop。pop 是调用函数 quicklistPop 。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">quicklistPop</span><span class="token punctuation">(</span>quicklist <span class="token operator">*</span>quicklist<span class="token punctuation">,</span> <span class="token keyword">int</span> where<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>data<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>sz<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>slong<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>vstr<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> vlen<span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> vlong<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若当前 entry 为空，则直接返回 0；</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>quicklist<span class="token operator">-></span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 实际逻辑是调用 quicklistPopCustom 、在调用 ziplistGet 获取、 最后调用 quicklistDelIndex 删掉元素。</span>    <span class="token comment" spellcheck="true">// 具体的逻辑自行查阅代码</span>    <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">quicklistPopCustom</span><span class="token punctuation">(</span>quicklist<span class="token punctuation">,</span> where<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vstr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vlen<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vlong<span class="token punctuation">,</span> _quicklistSaver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token operator">*</span>data <span class="token operator">=</span> vstr<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>slong<span class="token punctuation">)</span>        <span class="token operator">*</span>slong <span class="token operator">=</span> vlong<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sz<span class="token punctuation">)</span>        <span class="token operator">*</span>sz <span class="token operator">=</span> vlen<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>得益于 quicklist 结构的友好设计，其实就是空间换时间。获取 list 的长度，是不需要遍历节点中的 ziplist 的个数。 这种设计在 redis  的各种数据结构中是十分常见的，我们在实际开发中其实也可以采纳这种设计思想。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">quicklistCount</span><span class="token punctuation">(</span><span class="token keyword">const</span> quicklist <span class="token operator">*</span>ql<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> <span class="token keyword">return</span> ql<span class="token operator">-></span>count<span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>对操作接口的解读就到这里了，感兴趣的可以直接去 quicklist.c 中查阅。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>List 数据类型的底层实现其实是 quicklist。</li><li>quicklist 是一个双向链表的复合结构体。quicklistNode 让它拥有链表的查询优点；ziplist 让它在内存使用上有着相对链表可以节省大量前后指针的优势。</li><li>但是需要合理的配置节点中 ziplist 的 entry 个数。entry 过少，则退化成普通链表。entry 过多，则会放大 ziplist 的缺点。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> quicklist </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>intset - 整数数组</title>
      <link href="/2021/06/26/intset-zheng-shu-shu-zu/"/>
      <url>/2021/06/26/intset-zheng-shu-shu-zu/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Set 是 Redis 数据类型的一种。集合中元素是唯一的，支持存储最大元素 2^64。因为是哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><p>但是 Set 除了哈希表之外，还有 intset 这种实现方式。 intset 是 Redis 独特设计的一种数据结构。当需要存储的数据全是正数且元素数量不大情况下，如 -2、-1、1、2…  Redis 首选 intset 作为实现方式。</p><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>在 intset.h 中定义了 intset 的结构体：</p><pre class=" language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> intset <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    uint32_t encoding<span class="token punctuation">;</span>     uint32_t length<span class="token punctuation">;</span>    int8_t contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> intset<span class="token punctuation">;</span></code></pre><ul><li><p><strong>encoding</strong>  编码方式。目前共支持三种范围：<br>  INTSET_ENC_INT16：占用 2 个字节，存储范围为 -2^16 ~  2^16-1。<br>  INTSET_ENC_INT32：占用 4 个字节，存储范围为 -2^32 ~  2^32-1。<br>  INTSET_ENC_INT64：占用 8 个字节，存储范围为 -2^64 ~  2^64-1。</p></li><li><p><strong>length</strong> 存储元素个数。</p></li><li><p><strong>contents</strong> 存储元素的正数数组。其元素特点是不重复且按照升序顺序排列。</p></li></ul><h4 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h4><h5 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h5><pre class=" language-c"><code class="language-c">intset <span class="token operator">*</span><span class="token function">intsetNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    intset <span class="token operator">*</span>is <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>intset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 分配内存</span>    is<span class="token operator">-></span>encoding <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>INTSET_ENC_INT16<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 默认编码为 INTSET_ENC_INT16</span>    is<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 默认长度为 0</span>    <span class="token keyword">return</span> is<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><pre class=" language-c"><code class="language-c">intset <span class="token operator">*</span><span class="token function">intsetAdd</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> int64_t value<span class="token punctuation">,</span> uint8_t <span class="token operator">*</span>success<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断当前插入的元素范围 获取合适的编码方式</span>    uint8_t valenc <span class="token operator">=</span> <span class="token function">_intsetValueEncoding</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32_t pos<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否进行扩容操作 </span>    <span class="token comment" spellcheck="true">// 如当前编码方式是 INTSET_ENC_INT16， 此时需要存入的数据小于 -2^16 或大于 2^16-1， 则需要进行扩容操作。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>valenc <span class="token operator">></span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 执行扩容 该函数下面在讲解</span>        <span class="token keyword">return</span> <span class="token function">intsetUpgradeAndAdd</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断该元素是否存在集合和确定当前元素的插入点</span>       <span class="token comment" spellcheck="true">// 使用了二分查询</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intsetSearch</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> is<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 调整集合    </span>        is <span class="token operator">=</span> <span class="token function">intsetResize</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">intsetMoveTail</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 真正写入集合的函数。</span>    <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>pos<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 长度加一</span>    is<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> is<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// intsetSearch 函数 </span><span class="token comment" spellcheck="true">// 查找给定值，若存在返回 1，pos为所在位置；若不存在返回 0，pos为可插入位置。</span><span class="token keyword">static</span> uint8_t <span class="token function">intsetSearch</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> int64_t value<span class="token punctuation">,</span> uint32_t <span class="token operator">*</span>pos<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> max <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    int64_t cur <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 空集合直接 return</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 若当前值超出当前编码方式的最大值，则 pos 为末尾值。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">></span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 若当前值超出当前编码方式的最小值，则 pos 为最头部。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当集合不为空 且当前值处于当前编码范围内。</span>    <span class="token comment" spellcheck="true">// 使用二分法进行查找，平均时间复杂度为 O(logn)。</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>max <span class="token operator">>=</span> min<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        mid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>min <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>max<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> <span class="token function">_intsetGet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">></span> cur<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            min <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> cur<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            max <span class="token operator">=</span> mid<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 若存在 则插入点就是当前位置。 </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 不存在 插入点为 min</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos<span class="token punctuation">)</span> <span class="token operator">*</span>pos <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><p>涉及到查找操作，如返回一个元素、判断元素是否存在、查询元素位置等操作都是调用 _intsetGet -&gt; _intsetGetEncoded函数。</p><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">// 返回给定编码的 pos 位置的值。</span><span class="token keyword">static</span> int64_t <span class="token function">_intsetGetEncoded</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> uint8_t enc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    int64_t v64<span class="token punctuation">;</span>    int32_t v32<span class="token punctuation">;</span>    int16_t v16<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>enc <span class="token operator">==</span> INTSET_ENC_INT64<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v64<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int64_t<span class="token operator">*</span><span class="token punctuation">)</span>is<span class="token operator">-></span>contents<span class="token punctuation">)</span><span class="token operator">+</span>pos<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>v64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memrev64ifbe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v64<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> v64<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>enc <span class="token operator">==</span> INTSET_ENC_INT32<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v32<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int32_t<span class="token operator">*</span><span class="token punctuation">)</span>is<span class="token operator">-></span>contents<span class="token punctuation">)</span><span class="token operator">+</span>pos<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>v32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memrev32ifbe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v32<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> v32<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v16<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int16_t<span class="token operator">*</span><span class="token punctuation">)</span>is<span class="token operator">-></span>contents<span class="token punctuation">)</span><span class="token operator">+</span>pos<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>v16<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">memrev16ifbe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v16<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> v16<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><pre class=" language-c"><code class="language-c">intset <span class="token operator">*</span><span class="token function">intsetRemove</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> int64_t value<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>success<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    uint8_t valenc <span class="token operator">=</span> <span class="token function">_intsetValueEncoding</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint32_t pos<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当给定值处于当前集合的编码范围且存在集合当中    </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>valenc <span class="token operator">&lt;=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>encoding<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">intsetSearch</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        uint32_t len <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token operator">*</span>success <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 调整集合</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token punctuation">(</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">intsetMoveTail</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>pos<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>        is <span class="token operator">=</span> <span class="token function">intsetResize</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 长度减 1</span>        is<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>len<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> is<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="集合扩容"><a href="#集合扩容" class="headerlink" title="集合扩容"></a>集合扩容</h5><p>Set 只有扩容操作，不能缩小。所以触犯扩容都是在添加元素时候超过了原来的编码方式。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">static</span> intset <span class="token operator">*</span><span class="token function">intsetUpgradeAndAdd</span><span class="token punctuation">(</span>intset <span class="token operator">*</span>is<span class="token punctuation">,</span> int64_t value<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前集合的编码方式</span>    uint8_t curenc <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// value 确定新的集合的编码方式</span>    uint8_t newenc <span class="token operator">=</span> <span class="token function">_intsetValueEncoding</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确定数据插入的位置。</span>    <span class="token keyword">int</span> prepend <span class="token operator">=</span> value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 首先设置新的编码和调整大小</span>    is<span class="token operator">-></span>encoding <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>newenc<span class="token punctuation">)</span><span class="token punctuation">;</span>    is <span class="token operator">=</span> <span class="token function">intsetResize</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 避免覆盖数据 采用从后往前的重编码顺序。</span>   <span class="token comment" spellcheck="true">// 如原有 1、2、3 使用INTSET_ENC_INT16，现在需要加入 65538 需要用 INTSET_ENC_INT32。 </span>    <span class="token keyword">while</span><span class="token punctuation">(</span>length<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>length<span class="token operator">+</span>prepend<span class="token punctuation">,</span><span class="token function">_intsetGetEncoded</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>length<span class="token punctuation">,</span>curenc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 将待添加的 value 添加到首部或者尾部, 因为是扩容所以 value 是大于原有最大值或小于最小值。</span>   <span class="token comment" spellcheck="true">// _intsetSet 为实际写如的逻辑。详情见源码 。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>prepend<span class="token punctuation">)</span>        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">_intsetSet</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    is<span class="token operator">-></span>length <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">intrev32ifbe</span><span class="token punctuation">(</span>is<span class="token operator">-></span>length<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> is<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>intset 是 Set 除哈希表外的一种实现方式，当所有数据为正数时候 Redis 会采用 intset。intset 实现上相对其他的数据结构是比较简单的。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> intset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ziplist - 压缩列表</title>
      <link href="/2021/06/20/ziplist-ya-suo-lie-biao/"/>
      <url>/2021/06/20/ziplist-ya-suo-lie-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>相信对使用过 Redis 的人来说，数据类型 List 是不会陌生的吧。大多数人需要实现一个队列时候，首选的就是 List 了。但是其实 Redis 的 List 类型有多种实现方式。这篇文章就是介绍其中一种实现 ziplist - 压缩列表。</p><h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>一如既往，关于 ziplist 的定义和实现还是放在一对文件中，分别是 ziplist.h 和 ziplist.c。在 ziplist.c 文件的头部有着这么一段注释介绍什么是 ziplist。</p><blockquote><p>ziplist 是一个经过特殊编码的双向链表，旨在提高内存效率。 它存储字符串和整数值，其中整数被编码为实际整数而不是一系列字符。 它允许在 O(1) 时间内在列表的任一侧进行推送和弹出操作。 但是，由于每个操作都需要重新分配 ziplist 使用的内存，因此实际复杂性与 ziplist 使用的内存量有关。</p></blockquote><p>从这段话得到：对于不同的数据类型有着不同的编码方式，理解为会对数据进行压缩，从而达到减少内存使用的目的。但是随着存储的 value 数据级增加，使用 ziplist 所付出的代价也随之增加。</p><h4 id="ziplist-布局"><a href="#ziplist-布局" class="headerlink" title="ziplist 布局"></a>ziplist 布局</h4><p>ziplist 是一个特殊双向链表，不像普通的链表使用前后指针关联在一起，它是存储在连续内存上的。整体的结构布局如下图：<br><img src="https://img-blog.csdnimg.cn/20210530162914153.png#pic_center" alt="在这里插入图片描述"></p><ol><li>zlbytes: 32 位无符号整型，记录 ziplist 整个结构体的占用空间大小。当然了也包括 zlbytes 本身。这个结构有个很大的用处，就是当需要修改 ziplist 时候不需要遍历即可知道其本身的大小。 这个 SDS 中记录字符串的长度有相似之处，这些好的设计往往在平时的开发中可以采纳一下。</li><li>zltail: 32 位无符号整型, 记录整个 ziplist 中最后一个 entry 的偏移量。所以在尾部进行 POP 操作时候不需要先遍历一次。</li><li>zllen: 16 位无符号整型,  记录 entry 的数量， 所以只能表示 2^16。但是 Redis 作了特殊的处理：当实体数超过 2^16  ,该值被固定为 2^16 - 1。 所以这种时候要知道所有实体的数量就必须要遍历整个结构了。</li><li>entry: 真正存数据的结构。</li><li>zlend: 8 位无符号整型, 固定为 255 。为 ziplist 的结束标识。</li></ol><h4 id="entry-结构"><a href="#entry-结构" class="headerlink" title="entry 结构"></a>entry 结构</h4><p>每个 entry 都包含两条信息的元数据为前缀。 第一元数据用来存储前一个 entry 的长度，以便能够从后向前遍历列表。<br> 第二元数据是表示 entry 的编码形式。 用来表示 entry 类型，整数或字符串，在字符串的情况下，它还表示字符串有效的长度。 </p><p>所以一个完整的 ziplist 是这样存储的：</p><p><img src="https://img-blog.csdnimg.cn/20210530170201254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxNTA0NTQ1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="prelen"><a href="#prelen" class="headerlink" title="prelen"></a>prelen</h5><p>记录前一个 entry 的长度。若前一个 entry 的长度小于 254 , 则使用 1 个字节的 8 位无符号整数来表示。</p><p>若前一个 entry 长度大于等于 254，则使用 5 个字节来表示。第 1 个字节固定为 254 (FE) 作为标识，剩余 4 字节则用来表示前一个 entry 的实际大小。</p><p>所以两种情况下的 entry 结构如下所示：</p><pre><code>1. 前一个 entry 大小不超过 253。&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;2. 前一个 entry 大小超过 253。0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</code></pre><h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>entry 的编码字段取决于条目的内容。</p><p>一、当 entry 是字符串时，编码第 1 个字节的前 2 位将保存用于存储字符串长度的编码类型，后面是字符串的实际长度。 </p><p>如注释中举例：</p><pre><code>1. 长度小于或等于 63 字节（6 位）的字符串值。 “pppppp”表示无符号的 6 位数据长度。|00pppppp| - 1 byte</code></pre><pre><code>2. 长度小于或等于 16383 字节（14 位）的字符串值。14 位的数据采用  big endian 存储。big endian 是一种字节序方式，有Little-Endian、Big-Endian两种。|01pppppp|qqqqqqqq| - 2 bytes</code></pre><pre><code>3. 长度大于或等于 16384 字节的字符串值。采用 big endian 存储且可表示的字符串长度最大2^32-1，所以第一个字节没有用到，所以低6位没有用，所以都是0。|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes </code></pre><p>二、当 entry 是整数时，前 2 位都固定为 1。接下来的 2 位用于指定将在此标头后存储哪种类型的整数。</p><p><em>与 ziplist 标头一样，所有整数都以 Little-Endian 序表示，即使此代码是在 Big-Endian 系统中编译的。</em></p><p>如注释中举例：</p><pre><code>1. 整数编码为 int16_t（2 字节）。|11000000| - 3 bytes</code></pre><pre><code>2. 整数编码为int32_t（4个字节）。|11010000| - 5 bytes</code></pre><pre><code>3. 整数编码为 int64_t（8 字节）。|11100000| - 9 bytes</code></pre><pre><code>4. 整数编码为24位带符号（3个字节）。|11110000| - 4 bytes</code></pre><pre><code>5. 整数编码为 8 位有符号（1 字节）。|11111110| - 2 bytes</code></pre><pre><code>6. 0到12的无符号整数。编码后的值实际上是1到13，因为0000和1111不能用，所以要从编码后的4位值中减去1才能得到正确的值。|1111xxxx| - (with xxxx between 0001 and 1101) immediate 4 bit integer</code></pre><pre><code>7. 表示 ziplist 结尾的标识。|11111111|</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>ziplist 为了节省内存，采用了紧凑的连续存储。所以在修改操作下并不能像一般的链表那么容易，需要从新分配新的内存，然后复制到新的空间。</li><li>ziplist 是一个双向链表，可以在时间复杂度为O(1)从下头部、尾部进行pop或push。</li><li>可能会出现连锁更新现象。</li></ol><p>其实使用中并没有直接操作这种数据结构，但是可以设置何种情况下使用它。可以在 Redis 的配置文件中进行设置。</p><p>如有以下可选设置项：</p><ol><li>hash-max-ziplist-entries：hash 类型元素数量超过指定数据后时候。使用 hash 存储， 否则使用压缩表。</li><li>hash-max-ziplist-value： hash 类型元素长度超过指定数据后时候。 使用 hash 存储，否则使用压缩链表。</li><li>zset-max-ziplist-entries：zset 类型 压缩列表 ziplist 最大限制元素数。超过指定值将会使用跳表 skiplist + dict 来存储。</li><li>zset-max-ziplist-value：set 类型 压缩列表 ziplist 最大限制大小。超过指定将会使用跳表 skiplist+dict 来存储。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> ziplist </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
